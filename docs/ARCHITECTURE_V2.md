# GlobalID 2.0 - å…¨æ–°æ¶æ„è®¾è®¡

> **ä»é›¶å¼€å§‹é‡æ„** - ç°ä»£åŒ–ã€å¯æ‰©å±•ã€æ™ºèƒ½åŒ–çš„ä¼ æŸ“ç—…æ•°æ®åˆ†æå¹³å°

---

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

### å½“å‰ç—›ç‚¹
1. âŒ æ–°ç–¾ç—…éœ€è¦æ‰‹åŠ¨æäº¤ä»£ç 
2. âŒ å•ä¸€å›½å®¶ï¼Œéš¾ä»¥æ‰©å±•
3. âŒ AIéªŒè¯AIæµªè´¹èµ„æº
4. âŒ è¿”å›ç©ºå­—ç¬¦ä¸²å¯¼è‡´é™é»˜å¤±è´¥
5. âŒ ä»£ç éš¾ä»¥ç»´æŠ¤
6. âŒ æ— æ³•è‡ªåŠ¨æ¢å¤

### æ–°æ¶æ„ç›®æ ‡
1. âœ… ç–¾ç—…è‡ªåŠ¨è¯†åˆ«å’Œæ˜ å°„
2. âœ… å¤šå›½å®¶å³æ’å³ç”¨
3. âœ… æ™ºèƒ½éªŒè¯æœºåˆ¶ï¼ˆå¤šä¸“å®¶äº¤å‰éªŒè¯ï¼‰
4. âœ… å¤±è´¥è‡ªåŠ¨æ¢å¤å’Œé™çº§
5. âœ… æ¨¡å—åŒ–ã€å¯æµ‹è¯•
6. âœ… å®Œæ•´çš„ç›‘æ§å’Œæ—¥å¿—

---

## ğŸ—ï¸ æ¶æ„æ¦‚è§ˆ

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    GlobalID 2.0 Platform                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚  Data Layer  â”‚  â”‚  AI Layer    â”‚  â”‚ Output Layer â”‚      â”‚
â”‚  â”‚              â”‚  â”‚              â”‚  â”‚              â”‚      â”‚
â”‚  â”‚  â€¢ Crawlers  â”‚  â”‚  â€¢ Agents    â”‚  â”‚  â€¢ Reports   â”‚      â”‚
â”‚  â”‚  â€¢ Parsers   â”‚  â”‚  â€¢ Validatorsâ”‚  â”‚  â€¢ Website   â”‚      â”‚
â”‚  â”‚  â€¢ Normalizerâ”‚  â”‚  â€¢ Ensemble  â”‚  â”‚  â€¢ Email     â”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚         â”‚                  â”‚                  â”‚              â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚
â”‚                            â”‚                                 â”‚
â”‚                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                      â”‚
â”‚                  â”‚   Core Services    â”‚                      â”‚
â”‚                  â”‚                    â”‚                      â”‚
â”‚                  â”‚  â€¢ Disease Registryâ”‚                      â”‚
â”‚                  â”‚  â€¢ State Manager   â”‚                      â”‚
â”‚                  â”‚  â€¢ Cache Service   â”‚                      â”‚
â”‚                  â”‚  â€¢ Config Manager  â”‚                      â”‚
â”‚                  â”‚  â€¢ Event Bus       â”‚                      â”‚
â”‚                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                      â”‚
â”‚                                                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“¦ æŠ€æœ¯é€‰å‹

### 1. ç¼–ç¨‹è¯­è¨€å’Œæ¡†æ¶

```yaml
æ ¸å¿ƒè¯­è¨€: Python 3.11+
ç†ç”±:
  - ä¸°å¯Œçš„æ•°æ®å¤„ç†åº“
  - AI/MLç”Ÿæ€æˆç†Ÿ
  - å¼‚æ­¥æ”¯æŒï¼ˆasyncioï¼‰
  - ç±»å‹æç¤ºæ”¯æŒ

Webæ¡†æ¶: FastAPI
ç†ç”±:
  - ç°ä»£å¼‚æ­¥æ¡†æ¶
  - è‡ªåŠ¨APIæ–‡æ¡£
  - ç±»å‹å®‰å…¨
  - é«˜æ€§èƒ½

ä»»åŠ¡è°ƒåº¦: Celery + Redis
ç†ç”±:
  - åˆ†å¸ƒå¼ä»»åŠ¡é˜Ÿåˆ—
  - æ”¯æŒå®šæ—¶ä»»åŠ¡
  - å¯æ‰©å±•
  - å¤±è´¥é‡è¯•
```

### 2. æ•°æ®å­˜å‚¨

```yaml
å…³ç³»æ•°æ®åº“: PostgreSQL
ç”¨é€”: 
  - ç–¾ç—…æ•°æ®å­˜å‚¨
  - å…ƒæ•°æ®ç®¡ç†
  - æŸ¥è¯¢åˆ†æ
ç†ç”±:
  - JSONBæ”¯æŒï¼ˆçµæ´»schemaï¼‰
  - å¼ºå¤§çš„æŸ¥è¯¢èƒ½åŠ›
  - å¯é æ€§é«˜

çˆ¬å–å®¡è®¡ä¸åŸå§‹å­˜æ¡£:
    - åŸå§‹ç½‘é¡µè½¬çº¯æ–‡æœ¬ä¿å­˜åˆ° data/raw/<country>/<run_id>/...
    - æ•°æ®åº“è®°å½•è¿è¡Œå’Œæ–‡ä»¶è·¯å¾„ (crawl_runs, crawl_raw_pages)

æ–‡æ¡£æ•°æ®åº“: MongoDB (å¯é€‰)
ç”¨é€”:
  - åŸå§‹çˆ¬å–æ•°æ®
  - æ—¥å¿—å­˜å‚¨
  - çµæ´»schema
ç†ç”±:
  - Schema-free
  - é€‚åˆéç»“æ„åŒ–æ•°æ®

ç¼“å­˜: Redis
ç”¨é€”:
  - APIå“åº”ç¼“å­˜
  - ä»»åŠ¡é˜Ÿåˆ—
  - å®æ—¶çŠ¶æ€
ç†ç”±:
  - æå¿«çš„è¯»å†™
  - ä¸°å¯Œçš„æ•°æ®ç»“æ„
  - æŒä¹…åŒ–æ”¯æŒ

æ—¶åºæ•°æ®åº“: TimescaleDB (PostgreSQLæ‰©å±•)
ç”¨é€”:
  - ç–¾ç—…æ—¶é—´åºåˆ—
  - è¶‹åŠ¿åˆ†æ
ç†ç”±:
  - åŸç”ŸSQLæ”¯æŒ
  - é«˜æ•ˆå‹ç¼©
  - è‡ªåŠ¨åˆ†åŒº
```

### 3. AI/LLMé›†æˆ

```yaml
ä¸»è¦LLM:
  - OpenAI GPT-4o (åˆ›ä½œ)
  - Claude 3.5 Sonnet (åˆ†æ)
  - å¼€æºæ¨¡å‹ (å¤‡é€‰)

LLMæ¡†æ¶: LangChain
ç†ç”±:
  - ç»Ÿä¸€çš„LLMæ¥å£
  - é“¾å¼è°ƒç”¨
  - Agentæ”¯æŒ
  - ä¸°å¯Œçš„å·¥å…·

å‘é‡æ•°æ®åº“: Qdrant / Milvus
ç”¨é€”:
  - ç–¾ç—…çŸ¥è¯†åº“
  - è¯­ä¹‰æœç´¢
  - RAG (æ£€ç´¢å¢å¼ºç”Ÿæˆ)

åµŒå…¥æ¨¡å‹: 
  - OpenAI text-embedding-3
  - BGE-M3 (ä¸­è‹±åŒè¯­)
```

### 4. ç½‘ç«™ç”Ÿæˆ

```yaml
é™æ€ç«™ç‚¹ç”Ÿæˆå™¨: 
é€‰é¡¹1: Next.js (React)
  - ä¼˜åŠ¿: SEOä¼˜åŒ–ã€ç°ä»£åŒ–ã€å¯äº¤äº’
  - åŠ£åŠ¿: éœ€è¦Node.jsç¯å¢ƒ

é€‰é¡¹2: Hugo (å½“å‰)
  - ä¼˜åŠ¿: æå¿«ã€ç®€å•ã€çº¯é™æ€
  - åŠ£åŠ¿: äº¤äº’æ€§æœ‰é™

é€‰é¡¹3: Astro (æ¨è)
  - ä¼˜åŠ¿: æ€§èƒ½+äº¤äº’æ€§
  - æ”¯æŒå¤šæ¡†æ¶
  - éƒ¨åˆ†æ°´åˆ

æ¨è: Astro + Vue/React ç»„ä»¶
ç†ç”±:
  - é™æ€ä¼˜å…ˆ
  - å¯é€‰äº¤äº’æ€§
  - ä¼˜ç§€çš„å¼€å‘ä½“éªŒ
```

### 5. éƒ¨ç½²å’Œç›‘æ§

```yaml
å®¹å™¨åŒ–: Docker + Docker Compose
ç†ç”±:
  - ç¯å¢ƒä¸€è‡´æ€§
  - æ˜“äºéƒ¨ç½²
  - æœåŠ¡éš”ç¦»

CI/CD: GitHub Actions
ç†ç”±:
  - ä¸ä»£ç åº“é›†æˆ
  - å…è´¹é¢åº¦å……è¶³
  - æ˜“äºé…ç½®

ç›‘æ§:
  - Prometheus (æŒ‡æ ‡)
  - Grafana (å¯è§†åŒ–)
  - Sentry (é”™è¯¯è¿½è¸ª)
  - Loki (æ—¥å¿—èšåˆ)

å®šæ—¶ä»»åŠ¡: 
  - Celery Beat (ä»£ç å†…)
  - æˆ– GitHub Actions Cron
```

---

## ğŸ¨ æ–°æ¶æ„è®¾è®¡

### é¡¹ç›®ç»“æ„

```
globalid-v2/
â”œâ”€â”€ README.md
â”œâ”€â”€ docker-compose.yml
â”œâ”€â”€ .env.example
â”œâ”€â”€ pyproject.toml              # Poetryä¾èµ–ç®¡ç†
â”‚
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚
â”‚   â”œâ”€â”€ core/                   # æ ¸å¿ƒæœåŠ¡
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ config.py          # é…ç½®ç®¡ç†ï¼ˆPydanticï¼‰
â”‚   â”‚   â”œâ”€â”€ database.py        # æ•°æ®åº“è¿æ¥
â”‚   â”‚   â”œâ”€â”€ cache.py           # ç¼“å­˜æœåŠ¡
â”‚   â”‚   â”œâ”€â”€ events.py          # äº‹ä»¶æ€»çº¿
â”‚   â”‚   â””â”€â”€ logging.py         # æ—¥å¿—é…ç½®
â”‚   â”‚
â”‚   â”œâ”€â”€ domain/                 # é¢†åŸŸæ¨¡å‹
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ models.py          # æ•°æ®æ¨¡å‹ï¼ˆPydanticï¼‰
â”‚   â”‚   â”œâ”€â”€ disease.py         # ç–¾ç—…å®ä½“
â”‚   â”‚   â”œâ”€â”€ country.py         # å›½å®¶å®ä½“
â”‚   â”‚   â””â”€â”€ report.py          # æŠ¥å‘Šå®ä½“
â”‚   â”‚
â”‚   â”œâ”€â”€ data/                   # æ•°æ®å±‚
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ crawler/           # çˆ¬è™«
â”‚   â”‚   â”‚   â”œâ”€â”€ base.py        # åŸºç¡€çˆ¬è™«ç±»
â”‚   â”‚   â”‚   â”œâ”€â”€ cn_cdc.py      # ä¸­å›½CDC
â”‚   â”‚   â”‚   â”œâ”€â”€ cn_gov.py      # ä¸­å›½æ”¿åºœ
â”‚   â”‚   â”‚   â”œâ”€â”€ us_cdc.py      # ç¾å›½CDCï¼ˆå¾…å®ç°ï¼‰
â”‚   â”‚   â”‚   â””â”€â”€ who.py         # WHOï¼ˆå¾…å®ç°ï¼‰
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ parser/            # è§£æå™¨
â”‚   â”‚   â”‚   â”œâ”€â”€ base.py
â”‚   â”‚   â”‚   â”œâ”€â”€ html_parser.py
â”‚   â”‚   â”‚   â””â”€â”€ pdf_parser.py
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ normalizer/        # æ•°æ®æ ‡å‡†åŒ–
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”œâ”€â”€ disease_mapper.py  # ç–¾ç—…æ˜ å°„
â”‚   â”‚   â”‚   â”œâ”€â”€ language.py        # è¯­è¨€æ ‡å‡†åŒ–
â”‚   â”‚   â”‚   â””â”€â”€ location.py        # åœ°ç†ä½ç½®æ ‡å‡†åŒ–
â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€ storage/           # æ•°æ®å­˜å‚¨
â”‚   â”‚       â”œâ”€â”€ __init__.py
â”‚   â”‚       â”œâ”€â”€ postgres.py
â”‚   â”‚       â””â”€â”€ file_storage.py
â”‚   â”‚
â”‚   â”œâ”€â”€ ai/                     # AIå±‚
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ agents/            # AIä»£ç†
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”œâ”€â”€ base_agent.py
â”‚   â”‚   â”‚   â”œâ”€â”€ analyst.py     # æ•°æ®åˆ†æä¸“å®¶
â”‚   â”‚   â”‚   â”œâ”€â”€ writer.py      # æŠ¥å‘Šæ’°å†™ä¸“å®¶
â”‚   â”‚   â”‚   â”œâ”€â”€ translator.py  # ç¿»è¯‘ä¸“å®¶
â”‚   â”‚   â”‚   â””â”€â”€ reviewer.py    # å®¡æŸ¥ä¸“å®¶
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ validators/        # éªŒè¯å™¨
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”œâ”€â”€ ensemble.py    # é›†æˆéªŒè¯
â”‚   â”‚   â”‚   â”œâ”€â”€ rules.py       # è§„åˆ™éªŒè¯
â”‚   â”‚   â”‚   â”œâ”€â”€ llm_judge.py   # LLMè¯„åˆ¤
â”‚   â”‚   â”‚   â””â”€â”€ metrics.py     # è´¨é‡æŒ‡æ ‡
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ prompts/           # æç¤ºè¯ç®¡ç†
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”œâ”€â”€ templates/
â”‚   â”‚   â”‚   â””â”€â”€ registry.py
â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€ llm/               # LLMå®¢æˆ·ç«¯
â”‚   â”‚       â”œâ”€â”€ __init__.py
â”‚   â”‚       â”œâ”€â”€ openai_client.py
â”‚   â”‚       â”œâ”€â”€ claude_client.py
â”‚   â”‚       â”œâ”€â”€ router.py      # æ¨¡å‹è·¯ç”±
â”‚   â”‚       â””â”€â”€ fallback.py    # é™çº§ç­–ç•¥
â”‚   â”‚
â”‚   â”œâ”€â”€ analysis/               # åˆ†æå±‚
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ statistics.py      # ç»Ÿè®¡åˆ†æ
â”‚   â”‚   â”œâ”€â”€ trends.py          # è¶‹åŠ¿åˆ†æ
â”‚   â”‚   â”œâ”€â”€ comparison.py      # å¯¹æ¯”åˆ†æ
â”‚   â”‚   â””â”€â”€ forecasting.py     # é¢„æµ‹ï¼ˆå¯é€‰ï¼‰
â”‚   â”‚
â”‚   â”œâ”€â”€ generation/             # ç”Ÿæˆå±‚
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ report/
â”‚   â”‚   â”‚   â”œâ”€â”€ generator.py   # æŠ¥å‘Šç”Ÿæˆå™¨
â”‚   â”‚   â”‚   â”œâ”€â”€ sections.py    # å„ç« èŠ‚ç”Ÿæˆ
â”‚   â”‚   â”‚   â””â”€â”€ templates.py   # æŠ¥å‘Šæ¨¡æ¿
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ visualization/
â”‚   â”‚   â”‚   â”œâ”€â”€ charts.py      # å›¾è¡¨ç”Ÿæˆ
â”‚   â”‚   â”‚   â””â”€â”€ maps.py        # åœ°å›¾ç”Ÿæˆ
â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€ website/
â”‚   â”‚       â”œâ”€â”€ builder.py     # ç½‘ç«™æ„å»º
â”‚   â”‚       â””â”€â”€ deployer.py    # éƒ¨ç½²
â”‚   â”‚
â”‚   â”œâ”€â”€ services/               # ä¸šåŠ¡æœåŠ¡
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ disease_registry.py    # ç–¾ç—…æ³¨å†Œè¡¨
â”‚   â”‚   â”œâ”€â”€ crawler_service.py     # çˆ¬è™«æœåŠ¡
â”‚   â”‚   â”œâ”€â”€ report_service.py      # æŠ¥å‘ŠæœåŠ¡
â”‚   â”‚   â”œâ”€â”€ email_service.py       # é‚®ä»¶æœåŠ¡
â”‚   â”‚   â””â”€â”€ state_manager.py       # çŠ¶æ€ç®¡ç†
â”‚   â”‚
â”‚   â”œâ”€â”€ api/                    # APIå±‚ï¼ˆå¯é€‰ï¼‰
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ main.py            # FastAPIåº”ç”¨
â”‚   â”‚   â”œâ”€â”€ routes/
â”‚   â”‚   â”‚   â”œâ”€â”€ health.py
â”‚   â”‚   â”‚   â”œâ”€â”€ reports.py
â”‚   â”‚   â”‚   â””â”€â”€ diseases.py
â”‚   â”‚   â””â”€â”€ dependencies.py
â”‚   â”‚
â”‚   â””â”€â”€ cli/                    # å‘½ä»¤è¡Œæ¥å£
â”‚       â”œâ”€â”€ __init__.py
â”‚       â””â”€â”€ commands.py
â”‚
â”œâ”€â”€ tasks/                      # Celeryä»»åŠ¡
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ crawl.py
â”‚   â”œâ”€â”€ analyze.py
â”‚   â””â”€â”€ generate.py
â”‚
â”œâ”€â”€ tests/                      # æµ‹è¯•
â”‚   â”œâ”€â”€ unit/
â”‚   â”œâ”€â”€ integration/
â”‚   â””â”€â”€ e2e/
â”‚
â”œâ”€â”€ data/                       # æ•°æ®ç›®å½•
â”‚   â”œâ”€â”€ raw/                   # åŸå§‹æ•°æ®
â”‚   â”œâ”€â”€ processed/             # å¤„ç†åæ•°æ®
â”‚   â”œâ”€â”€ cache/                 # ç¼“å­˜
â”‚   â””â”€â”€ outputs/               # è¾“å‡º
â”‚
â”œâ”€â”€ configs/                    # é…ç½®æ–‡ä»¶
â”‚   â”œâ”€â”€ diseases.yaml          # ç–¾ç—…é…ç½®
â”‚   â”œâ”€â”€ countries.yaml         # å›½å®¶é…ç½®
â”‚   â”œâ”€â”€ models.yaml            # AIæ¨¡å‹é…ç½®
â”‚   â””â”€â”€ deployment.yaml        # éƒ¨ç½²é…ç½®
â”‚
â”œâ”€â”€ scripts/                    # å·¥å…·è„šæœ¬
â”‚   â”œâ”€â”€ setup.sh
â”‚   â”œâ”€â”€ migrate.py
â”‚   â””â”€â”€ seed.py
â”‚
â”œâ”€â”€ website/                    # ç½‘ç«™æºç 
â”‚   â”œâ”€â”€ astro.config.mjs
â”‚   â”œâ”€â”€ src/
â”‚   â””â”€â”€ public/
â”‚
â””â”€â”€ docs/                       # æ–‡æ¡£
    â”œâ”€â”€ architecture.md
    â”œâ”€â”€ api.md
    â””â”€â”€ deployment.md
```

---

## ğŸ§  æ ¸å¿ƒåˆ›æ–°è®¾è®¡

### 1. è‡ªåŠ¨ç–¾ç—…è¯†åˆ«å’Œæ˜ å°„ç³»ç»Ÿ

#### é—®é¢˜
å½“å‰éœ€è¦æ‰‹åŠ¨æ·»åŠ æ–°ç–¾ç—…åˆ°mappingè¡¨

#### è§£å†³æ–¹æ¡ˆï¼šæ™ºèƒ½ç–¾ç—…æ³¨å†Œè¡¨

```python
# src/services/disease_registry.py

from typing import Dict, List, Optional
from dataclasses import dataclass
from enum import Enum
import re

class DiseaseMatchStrategy(Enum):
    EXACT = "exact"              # ç²¾ç¡®åŒ¹é…
    FUZZY = "fuzzy"              # æ¨¡ç³ŠåŒ¹é…
    SEMANTIC = "semantic"        # è¯­ä¹‰åŒ¹é…ï¼ˆå‘é‡ï¼‰
    LLM_ASSISTED = "llm"         # LLMè¾…åŠ©

@dataclass
class Disease:
    id: str                      # å”¯ä¸€IDï¼ˆWHO codeæˆ–è‡ªå®šä¹‰ï¼‰
    names: Dict[str, List[str]]  # å¤šè¯­è¨€åç§°
    aliases: List[str]           # åˆ«å
    category: str                # åˆ†ç±»
    icd_codes: List[str]        # ICD-11ç¼–ç 
    embedding: Optional[List[float]] = None  # å‘é‡è¡¨ç¤º
    
class DiseaseRegistry:
    """æ™ºèƒ½ç–¾ç—…æ³¨å†Œè¡¨"""
    
    def __init__(self, db, vector_store, embedding_model, llm):
        self.db = db
        self.vector_store = vector_store
        self.embedding_model = embedding_model
        self.llm = llm
        self._cache = {}
        
    async def match(self, disease_text: str, 
                   language: str = "zh",
                   strategy: DiseaseMatchStrategy = DiseaseMatchStrategy.SEMANTIC,
                   confidence_threshold: float = 0.8) -> Optional[Disease]:
        """
        æ™ºèƒ½åŒ¹é…ç–¾ç—…
        
        Args:
            disease_text: ç–¾ç—…æ–‡æœ¬ï¼ˆå¦‚"ç”²å‹æµæ„Ÿ"ï¼‰
            language: è¯­è¨€ä»£ç 
            strategy: åŒ¹é…ç­–ç•¥
            confidence_threshold: ç½®ä¿¡åº¦é˜ˆå€¼
            
        Returns:
            åŒ¹é…çš„ç–¾ç—…å¯¹è±¡ï¼Œå¦‚æœç½®ä¿¡åº¦ä½åˆ™è¿”å›None
        """
        
        # 1. å°è¯•ç¼“å­˜
        cache_key = f"{language}:{disease_text}"
        if cache_key in self._cache:
            return self._cache[cache_key]
        
        # 2. ç²¾ç¡®åŒ¹é…
        exact_match = await self._exact_match(disease_text, language)
        if exact_match:
            self._cache[cache_key] = exact_match
            return exact_match
        
        # 3. æ¨¡ç³ŠåŒ¹é…ï¼ˆç¼–è¾‘è·ç¦»ï¼‰
        if strategy in [DiseaseMatchStrategy.FUZZY, DiseaseMatchStrategy.SEMANTIC]:
            fuzzy_match = await self._fuzzy_match(disease_text, language)
            if fuzzy_match and fuzzy_match['score'] > confidence_threshold:
                disease = fuzzy_match['disease']
                self._cache[cache_key] = disease
                return disease
        
        # 4. è¯­ä¹‰åŒ¹é…ï¼ˆå‘é‡æœç´¢ï¼‰
        if strategy in [DiseaseMatchStrategy.SEMANTIC, DiseaseMatchStrategy.LLM_ASSISTED]:
            semantic_match = await self._semantic_match(disease_text, language)
            if semantic_match and semantic_match['score'] > confidence_threshold:
                disease = semantic_match['disease']
                self._cache[cache_key] = disease
                return disease
        
        # 5. LLMè¾…åŠ©è¯†åˆ«
        if strategy == DiseaseMatchStrategy.LLM_ASSISTED:
            llm_match = await self._llm_assisted_match(disease_text, language)
            if llm_match:
                # æ³¨å†Œæ–°ç–¾ç—…æˆ–å»ºè®®æ˜ å°„
                await self._register_or_suggest(disease_text, llm_match)
                return llm_match
        
        # 6. æ— æ³•åŒ¹é…ï¼Œè®°å½•å¾…å®¡æŸ¥
        await self._log_unknown_disease(disease_text, language)
        return None
    
    async def _semantic_match(self, text: str, language: str):
        """å‘é‡è¯­ä¹‰æœç´¢"""
        # ç”Ÿæˆembedding
        embedding = await self.embedding_model.encode(text)
        
        # åœ¨å‘é‡æ•°æ®åº“ä¸­æœç´¢
        results = await self.vector_store.search(
            embedding=embedding,
            limit=5,
            filters={"language": language}
        )
        
        if results and results[0]['score'] > 0.8:
            return {
                'disease': results[0]['metadata']['disease'],
                'score': results[0]['score']
            }
        return None
    
    async def _llm_assisted_match(self, text: str, language: str):
        """LLMè¾…åŠ©è¯†åˆ«"""
        known_diseases = await self._get_known_diseases(language)
        
        prompt = f"""
        ç»™å®šç–¾ç—…æ–‡æœ¬ï¼š{text}
        å·²çŸ¥ç–¾ç—…åˆ—è¡¨ï¼š{[d.names[language][0] for d in known_diseases]}
        
        ä»»åŠ¡ï¼š
        1. åˆ¤æ–­è¿™æ˜¯å¦æ˜¯ä¸€ä¸ªæ–°ç–¾ç—…
        2. å¦‚æœä¸æ˜¯ï¼Œæ‰¾å‡ºæœ€åŒ¹é…çš„å·²çŸ¥ç–¾ç—…ï¼ˆç»™å‡ºIDï¼‰
        3. ç»™å‡ºç½®ä¿¡åº¦åˆ†æ•°ï¼ˆ0-1ï¼‰
        
        è¿”å›JSONæ ¼å¼:
        {{
            "is_new": boolean,
            "matched_id": "disease_id" or null,
            "confidence": 0.95,
            "reason": "explanation"
        }}
        """
        
        response = await self.llm.generate(prompt, response_format="json")
        # è§£æå’Œå¤„ç†...
        
    async def register_new_disease(self, 
                                   name: str,
                                   language: str,
                                   category: str = None,
                                   auto_assign_id: bool = True):
        """
        æ³¨å†Œæ–°ç–¾ç—…ï¼ˆè‡ªåŠ¨æˆ–åŠè‡ªåŠ¨ï¼‰
        """
        # ç”ŸæˆID
        if auto_assign_id:
            disease_id = self._generate_disease_id(name, category)
        
        # åˆ›å»ºç–¾ç—…å¯¹è±¡
        disease = Disease(
            id=disease_id,
            names={language: [name]},
            aliases=[],
            category=category or await self._predict_category(name),
            icd_codes=await self._suggest_icd_codes(name)
        )
        
        # ç”Ÿæˆembedding
        disease.embedding = await self.embedding_model.encode(name)
        
        # ä¿å­˜åˆ°æ•°æ®åº“å’Œå‘é‡åº“
        await self.db.save(disease)
        await self.vector_store.add(disease)
        
        # å‘é€é€šçŸ¥ï¼ˆéœ€è¦äººå·¥å®¡æŸ¥ï¼‰
        await self._notify_new_disease(disease)
        
        return disease
```

**å·¥ä½œæµç¨‹**ï¼š

```
æ–°ç–¾ç—…æ–‡æœ¬ â†’ ç²¾ç¡®åŒ¹é… â†’ æ‰¾åˆ°ï¼Ÿè¿”å›
              â†“ æœªæ‰¾åˆ°
           æ¨¡ç³ŠåŒ¹é… â†’ æ‰¾åˆ°ï¼Ÿè¿”å›
              â†“ æœªæ‰¾åˆ°
           è¯­ä¹‰æœç´¢ â†’ æ‰¾åˆ°ï¼Ÿè¿”å›
              â†“ æœªæ‰¾åˆ°
           LLMè¯†åˆ« â†’ æ˜¯å·²çŸ¥ç–¾ç—…ï¼Ÿæ›´æ–°åˆ«å
              â†“ æ–°ç–¾ç—…
           è‡ªåŠ¨æ³¨å†Œ â†’ é€šçŸ¥å®¡æŸ¥ â†’ äººå·¥ç¡®è®¤
```

### 2. å¤šä¸“å®¶äº¤å‰éªŒè¯ç³»ç»Ÿ

#### é—®é¢˜
- å•ä¸€AIéªŒè¯ä¸å¯é 
- AIéªŒè¯AIæµªè´¹èµ„æº
- è¿”å›ç©ºå­—ç¬¦ä¸²""å¯¼è‡´é™é»˜å¤±è´¥

#### è§£å†³æ–¹æ¡ˆï¼šå¤šå±‚éªŒè¯ + ä¸“å®¶é›†æˆ

```python
# src/ai/validators/ensemble.py

from typing import List, Dict, Optional, Tuple
from enum import Enum
from dataclasses import dataclass

class ValidationType(Enum):
    RULE_BASED = "rule"          # è§„åˆ™éªŒè¯ï¼ˆå¿«é€Ÿï¼‰
    STATISTICAL = "statistical"   # ç»Ÿè®¡éªŒè¯
    LLM_SINGLE = "llm_single"    # å•ä¸€LLM
    LLM_ENSEMBLE = "llm_ensemble" # å¤šLLMé›†æˆ
    HUMAN_REVIEW = "human"       # äººå·¥å®¡æŸ¥

@dataclass
class ValidationResult:
    is_valid: bool
    confidence: float           # 0-1
    issues: List[str]           # å‘ç°çš„é—®é¢˜
    suggestions: List[str]      # æ”¹è¿›å»ºè®®
    validator_name: str
    
class EnsembleValidator:
    """é›†æˆéªŒè¯å™¨ - å¤šå±‚æ¬¡éªŒè¯ç­–ç•¥"""
    
    def __init__(self):
        self.validators = {
            'rule': RuleBasedValidator(),
            'statistical': StatisticalValidator(),
            'llm_judge': LLMJudgeValidator(),
            'format': FormatValidator(),
            'content': ContentValidator()
        }
        
    async def validate(self,
                      content: str,
                      content_type: str,  # 'introduction', 'highlights'ç­‰
                      context: Dict,      # ä¸Šä¸‹æ–‡æ•°æ®
                      strategy: str = "fast") -> Tuple[bool, ValidationResult]:
        """
        å¤šå±‚éªŒè¯ç­–ç•¥
        
        strategy:
            - "fast": åªç”¨è§„åˆ™éªŒè¯ï¼ˆå¿«é€Ÿï¼Œé€‚åˆå¼€å‘ï¼‰
            - "standard": è§„åˆ™ + ç»Ÿè®¡éªŒè¯ï¼ˆé»˜è®¤ï¼‰
            - "strict": è§„åˆ™ + ç»Ÿè®¡ + LLMè¯„åˆ¤ï¼ˆä¸¥æ ¼ï¼Œé€‚åˆç”Ÿäº§ï¼‰
            - "paranoid": æ‰€æœ‰éªŒè¯ + äººå·¥å®¡æŸ¥ï¼ˆæœ€ä¸¥æ ¼ï¼‰
        """
        
        results = []
        
        # Layer 1: è§„åˆ™éªŒè¯ï¼ˆå¿…é¡»é€šè¿‡ï¼‰
        rule_result = await self.validators['rule'].validate(
            content, content_type, context
        )
        results.append(rule_result)
        
        if not rule_result.is_valid and rule_result.confidence > 0.9:
            # è§„åˆ™éªŒè¯é«˜ç½®ä¿¡åº¦å¤±è´¥ï¼Œç›´æ¥æ‹’ç»
            return False, rule_result
        
        if strategy == "fast":
            return self._aggregate_results(results)
        
        # Layer 2: æ ¼å¼éªŒè¯
        format_result = await self.validators['format'].validate(
            content, content_type, context
        )
        results.append(format_result)
        
        # Layer 3: å†…å®¹éªŒè¯ï¼ˆç»Ÿè®¡ï¼‰
        if strategy in ["standard", "strict", "paranoid"]:
            content_result = await self.validators['content'].validate(
                content, content_type, context
            )
            results.append(content_result)
        
        # Layer 4: LLMè¯„åˆ¤ï¼ˆä»…åœ¨å¿…è¦æ—¶ï¼‰
        if strategy in ["strict", "paranoid"]:
            # å‰é¢çš„éªŒè¯æœ‰åˆ†æ­§æ—¶ï¼Œä½¿ç”¨LLM
            if self._has_disagreement(results):
                llm_result = await self.validators['llm_judge'].validate(
                    content, content_type, context
                )
                results.append(llm_result)
        
        # Layer 5: äººå·¥å®¡æŸ¥é˜Ÿåˆ—
        if strategy == "paranoid":
            await self._queue_for_human_review(content, results)
        
        return self._aggregate_results(results)
    
    def _aggregate_results(self, results: List[ValidationResult]) -> Tuple[bool, ValidationResult]:
        """
        èšåˆå¤šä¸ªéªŒè¯ç»“æœ
        
        ç­–ç•¥ï¼š
        - åŠ æƒæŠ•ç¥¨
        - é«˜ç½®ä¿¡åº¦ä¼˜å…ˆ
        - ä¿å®ˆç­–ç•¥ï¼ˆæœ‰ç–‘é—®å°±æ ‡è®°ï¼‰
        """
        
        # æƒé‡é…ç½®
        weights = {
            'rule': 2.0,         # è§„åˆ™éªŒè¯æƒé‡æœ€é«˜
            'format': 1.5,
            'statistical': 1.5,
            'content': 1.0,
            'llm_judge': 1.0
        }
        
        total_score = 0
        total_weight = 0
        all_issues = []
        all_suggestions = []
        
        for result in results:
            weight = weights.get(result.validator_name, 1.0)
            score = 1.0 if result.is_valid else 0.0
            total_score += score * result.confidence * weight
            total_weight += weight * result.confidence
            
            all_issues.extend(result.issues)
            all_suggestions.extend(result.suggestions)
        
        final_score = total_score / total_weight if total_weight > 0 else 0
        is_valid = final_score > 0.7  # é˜ˆå€¼
        
        return is_valid, ValidationResult(
            is_valid=is_valid,
            confidence=final_score,
            issues=all_issues,
            suggestions=all_suggestions,
            validator_name="ensemble"
        )


class RuleBasedValidator:
    """è§„åˆ™éªŒè¯å™¨ - å¿«é€Ÿã€ç¡®å®šæ€§"""
    
    def __init__(self):
        self.rules = {
            'introduction': [
                ('min_length', lambda x: len(x) >= 100),
                ('max_length', lambda x: len(x) <= 2000),
                ('has_numbers', lambda x: any(c.isdigit() for c in x)),
                ('no_error_messages', lambda x: not self._contains_error(x)),
                ('language_check', lambda x: self._check_language(x)),
            ],
            'highlights': [
                ('has_bullets', lambda x: '<br/>' in x or '\n-' in x),
                ('min_points', lambda x: x.count('<br/>') >= 3),
                ('max_points', lambda x: x.count('<br/>') <= 10),
                ('no_error_messages', lambda x: not self._contains_error(x)),
            ],
            # ... å…¶ä»–ç±»å‹çš„è§„åˆ™
        }
    
    async def validate(self, content: str, content_type: str, context: Dict):
        rules = self.rules.get(content_type, [])
        failed_rules = []
        
        for rule_name, rule_func in rules:
            if not rule_func(content):
                failed_rules.append(rule_name)
        
        is_valid = len(failed_rules) == 0
        confidence = 1.0 if is_valid else 0.95
        
        return ValidationResult(
            is_valid=is_valid,
            confidence=confidence,
            issues=[f"Rule failed: {r}" for r in failed_rules],
            suggestions=self._generate_suggestions(failed_rules, content_type),
            validator_name="rule"
        )
    
    def _contains_error(self, text: str) -> bool:
        """æ£€æŸ¥æ˜¯å¦åŒ…å«é”™è¯¯ä¿¡æ¯"""
        error_patterns = [
            r"I('m)? (sorry|unable|cannot|can't)",
            r"(error|failed|invalid)",
            r"please (try|provide)",
            r"I don't (have|know)",
            r"as an AI",
        ]
        
        for pattern in error_patterns:
            if re.search(pattern, text, re.IGNORECASE):
                return True
        return False
    
    def _check_language(self, text: str) -> bool:
        """æ£€æŸ¥è¯­è¨€æ˜¯å¦æ­£ç¡®ï¼ˆè‹±æ–‡ä¸ºä¸»ï¼‰"""
        # ç®€å•æ£€æŸ¥ï¼šè‹±æ–‡å­—ç¬¦å æ¯”
        english_chars = sum(1 for c in text if c.isascii() and c.isalpha())
        total_chars = sum(1 for c in text if c.isalpha())
        
        if total_chars == 0:
            return False
        
        ratio = english_chars / total_chars
        return ratio > 0.8  # 80%ä»¥ä¸Šæ˜¯è‹±æ–‡


class LLMJudgeValidator:
    """LLMè¯„åˆ¤éªŒè¯å™¨ - ä»…åœ¨å¿…è¦æ—¶ä½¿ç”¨"""
    
    def __init__(self, llm_client):
        self.llm = llm_client
        self.call_count = 0
        
    async def validate(self, content: str, content_type: str, context: Dict):
        """
        ä½¿ç”¨LLMè¯„åˆ¤ï¼Œä½†æ›´èªæ˜
        
        ç­–ç•¥ï¼š
        1. æä¾›æ˜ç¡®çš„è¯„åˆ¤æ ‡å‡†
        2. è¦æ±‚JSONæ ¼å¼è¾“å‡º
        3. ä½¿ç”¨æ›´ä¾¿å®œçš„æ¨¡å‹
        4. é™åˆ¶è°ƒç”¨æ¬¡æ•°
        """
        
        self.call_count += 1
        
        # æ„å»ºè¯„åˆ¤æ ‡å‡†
        criteria = self._get_criteria(content_type)
        
        prompt = f"""
You are a content quality judge. Evaluate the following {content_type} section.

Content:
{content}

Criteria:
{criteria}

Context:
- Disease: {context.get('disease')}
- Expected length: {context.get('expected_length')} words
- Must be in English
- Must be factual and professional

Evaluate and return JSON:
{{
    "is_valid": boolean,
    "confidence": 0.0-1.0,
    "issues": ["issue1", "issue2"],
    "score_breakdown": {{
        "factual_accuracy": 0.0-1.0,
        "clarity": 0.0-1.0,
        "completeness": 0.0-1.0,
        "format": 0.0-1.0
    }}
}}

Be strict. If content contains errors or is not in English, mark as invalid.
"""
        
        response = await self.llm.generate(
            prompt,
            model="gpt-4o-mini",  # ä½¿ç”¨æ›´ä¾¿å®œçš„æ¨¡å‹
            response_format="json",
            max_tokens=300
        )
        
        result = json.loads(response)
        
        return ValidationResult(
            is_valid=result['is_valid'],
            confidence=result['confidence'],
            issues=result['issues'],
            suggestions=[],
            validator_name="llm_judge"
        )
```

**éªŒè¯ç­–ç•¥å¯¹æ¯”**ï¼š

| ç­–ç•¥ | å±‚çº§ | é€Ÿåº¦ | æˆæœ¬ | å‡†ç¡®åº¦ | é€‚ç”¨åœºæ™¯ |
|------|------|------|------|--------|----------|
| Fast | è§„åˆ™ | âš¡âš¡âš¡ | $0 | 85% | å¼€å‘æµ‹è¯• |
| Standard | è§„åˆ™+ç»Ÿè®¡ | âš¡âš¡ | $0.01 | 92% | æ—¥å¸¸è¿è¡Œ |
| Strict | +LLMè¯„åˆ¤ | âš¡ | $0.05 | 97% | ç”Ÿäº§ç¯å¢ƒ |
| Paranoid | +äººå·¥å®¡æŸ¥ | ğŸŒ | $0.10+äººå·¥ | 99.9% | å…³é”®æŠ¥å‘Š |

### 3. æ™ºèƒ½å¤±è´¥å¤„ç†å’Œé™çº§ç­–ç•¥

#### é—®é¢˜
- è¿”å›ç©ºå­—ç¬¦ä¸²å¯¼è‡´é™é»˜å¤±è´¥
- æ²¡æœ‰é™çº§æ–¹æ¡ˆ

#### è§£å†³æ–¹æ¡ˆ

```python
# src/ai/llm/fallback.py

from typing import Optional, List, Callable
from enum import Enum
import logging

class FallbackStrategy(Enum):
    RETRY_SAME = "retry_same"              # é‡è¯•ç›¸åŒæ¨¡å‹
    SWITCH_MODEL = "switch_model"          # åˆ‡æ¢æ¨¡å‹
    USE_CACHE = "use_cache"                # ä½¿ç”¨ç¼“å­˜
    USE_TEMPLATE = "use_template"          # ä½¿ç”¨æ¨¡æ¿
    DEGRADE_QUALITY = "degrade_quality"    # é™çº§è´¨é‡è¦æ±‚
    SKIP_SECTION = "skip_section"          # è·³è¿‡æ­¤éƒ¨åˆ†
    HUMAN_INTERVENTION = "human"           # äººå·¥ä»‹å…¥

class SmartFallbackHandler:
    """æ™ºèƒ½é™çº§å¤„ç†å™¨"""
    
    def __init__(self, config):
        self.config = config
        self.fallback_chain = [
            FallbackStrategy.USE_CACHE,
            FallbackStrategy.RETRY_SAME,
            FallbackStrategy.SWITCH_MODEL,
            FallbackStrategy.USE_TEMPLATE,
            FallbackStrategy.DEGRADE_QUALITY,
            FallbackStrategy.HUMAN_INTERVENTION,
        ]
        
    async def handle_failure(self,
                            task: str,
                            error: Exception,
                            context: Dict,
                            attempted_strategies: List[FallbackStrategy] = None):
        """
        æ™ºèƒ½å¤±è´¥å¤„ç†
        
        Returns:
            (success, result, strategy_used)
        """
        
        attempted = attempted_strategies or []
        
        for strategy in self.fallback_chain:
            if strategy in attempted:
                continue
            
            logging.warning(f"Trying fallback strategy: {strategy.value}")
            
            try:
                if strategy == FallbackStrategy.USE_CACHE:
                    result = await self._try_cache(task, context)
                    if result:
                        return True, result, strategy
                
                elif strategy == FallbackStrategy.RETRY_SAME:
                    result = await self._retry_with_backoff(task, context)
                    if result:
                        return True, result, strategy
                
                elif strategy == FallbackStrategy.SWITCH_MODEL:
                    result = await self._try_alternative_model(task, context)
                    if result:
                        return True, result, strategy
                
                elif strategy == FallbackStrategy.USE_TEMPLATE:
                    result = await self._use_template(task, context)
                    return True, result, strategy  # æ¨¡æ¿æ€»æ˜¯æˆåŠŸ
                
                elif strategy == FallbackStrategy.DEGRADE_QUALITY:
                    # é™ä½è´¨é‡è¦æ±‚ï¼Œä½¿ç”¨æ›´ç®€å•çš„prompt
                    result = await self._generate_degraded(task, context)
                    if result:
                        return True, result, strategy
                
                elif strategy == FallbackStrategy.HUMAN_INTERVENTION:
                    # æ ‡è®°éœ€è¦äººå·¥å¤„ç†
                    await self._queue_for_human(task, context, error)
                    # è¿”å›å ä½å†…å®¹
                    return True, self._get_placeholder(task, context), strategy
                
            except Exception as e:
                logging.error(f"Fallback strategy {strategy} failed: {e}")
                attempted.append(strategy)
                continue
        
        # æ‰€æœ‰ç­–ç•¥éƒ½å¤±è´¥äº†
        return False, None, None
    
    async def _use_template(self, task: str, context: Dict) -> str:
        """
        ä½¿ç”¨é¢„å®šä¹‰æ¨¡æ¿
        
        å¥½å¤„ï¼š
        - æ°¸è¿œä¸ä¼šå¤±è´¥
        - æˆæœ¬ä¸ºé›¶
        - è´¨é‡å¯æ¥å—ï¼ˆè™½ç„¶ä¸å®Œç¾ï¼‰
        """
        
        templates = {
            'introduction': """
            # {disease}
            
            This report presents the epidemiological analysis of {disease} in {location} 
            for the period of {period}. The data shows {cases} cases and {deaths} deaths 
            were reported during this time.
            
            The analysis includes temporal trends, geographic distribution, and 
            comparative statistics with previous periods.
            """,
            
            'highlights': """
            - Total cases: {cases} ({change_cases} from previous period) <br/>
            - Total deaths: {deaths} ({change_deaths} from previous period) <br/>
            - Case fatality rate: {cfr}% <br/>
            - Peak month: {peak_month} <br/>
            """,
            
            # ... å…¶ä»–æ¨¡æ¿
        }
        
        template = templates.get(task, "Data for {disease}: {cases} cases, {deaths} deaths.")
        return template.format(**context)
```

### 4. å¤šå›½å®¶å³æ’å³ç”¨æ¶æ„

```python
# configs/countries.yaml

countries:
  - id: CN
    name: "China"
    sources:
      - type: cdc
        url: "https://weekly.chinacdc.cn"
        parser: cn_cdc_parser
        schedule: "0 10 * * *"  # æ¯å¤©10ç‚¹
      
      - type: gov
        url: "https://www.ndcpa.gov.cn/queryList"
        parser: cn_gov_parser
        schedule: "0 11 * * *"
    
    language: zh
    timezone: "Asia/Shanghai"
    report_templates: ["cn_template"]
    
  - id: US
    name: "United States"
    sources:
      - type: cdc
        url: "https://www.cdc.gov/nndss/data-statistics.html"
        parser: us_cdc_parser
        schedule: "0 15 * * 5"  # æ¯å‘¨äº”15ç‚¹
    
    language: en
    timezone: "America/New_York"
    report_templates: ["us_template"]
  
  - id: GLOBAL
    name: "Global (WHO)"
    sources:
      - type: who
        url: "https://www.who.int/emergencies/disease-outbreak-news"
        parser: who_parser
        schedule: "0 12 * * *"
    
    language: en
    timezone: "UTC"
    report_templates: ["who_template"]
```

```python
# src/data/crawler/base.py

from abc import ABC, abstractmethod

class BaseCrawler(ABC):
    """åŸºç¡€çˆ¬è™«ç±» - æ‰€æœ‰çˆ¬è™«ç»§æ‰¿æ­¤ç±»"""
    
    def __init__(self, config: Dict):
        self.config = config
        self.country_id = config['country_id']
        
    @abstractmethod
    async def fetch(self) -> List[RawData]:
        """è·å–åŸå§‹æ•°æ®"""
        pass
    
    @abstractmethod
    async def parse(self, raw_data: RawData) -> List[DiseaseRecord]:
        """è§£ææ•°æ®"""
        pass
    
    async def run(self) -> List[DiseaseRecord]:
        """è¿è¡Œå®Œæ•´æµç¨‹"""
        raw_data = await self.fetch()
        records = []
        
        for data in raw_data:
            parsed = await self.parse(data)
            records.extend(parsed)
        
        # æ ‡å‡†åŒ–
        normalized = await self.normalizer.normalize(records)
        
        return normalized
```

**æ·»åŠ æ–°å›½å®¶åªéœ€3æ­¥**ï¼š

1. åœ¨ `configs/countries.yaml` æ·»åŠ é…ç½®
2. åˆ›å»º `src/data/crawler/XX_crawler.py` 
3. åˆ›å»º `src/data/parser/XX_parser.py`

ä¸éœ€è¦ä¿®æ”¹æ ¸å¿ƒä»£ç ï¼

---

## ğŸš€ å®æ–½è·¯çº¿å›¾

### Phase 1: åŸºç¡€æ¶æ„ï¼ˆWeek 1-2ï¼‰

```bash
Week 1: é¡¹ç›®æ­å»º
â”œâ”€ Day 1-2: 
â”‚  â”œâ”€ åˆ›å»ºæ–°é¡¹ç›®ç»“æ„
â”‚  â”œâ”€ è®¾ç½® Docker ç¯å¢ƒ
â”‚  â”œâ”€ é…ç½® PostgreSQL + Redis
â”‚  â””â”€ é…ç½®åŸºç¡€ä¾èµ–
â”‚
â”œâ”€ Day 3-4:
â”‚  â”œâ”€ å®ç°æ ¸å¿ƒæœåŠ¡ï¼ˆconfig, logging, cacheï¼‰
â”‚  â”œâ”€ å®ç°ç–¾ç—…æ³¨å†Œè¡¨ï¼ˆåŸºç¡€ç‰ˆï¼‰
â”‚  â””â”€ æ•°æ®æ¨¡å‹å®šä¹‰
â”‚
â””â”€ Day 5:
   â”œâ”€ è¿ç§»ç°æœ‰æ•°æ®
   â”œâ”€ æµ‹è¯•åŸºç¡€åŠŸèƒ½
   â””â”€ æ–‡æ¡£ç¼–å†™

Week 2: æ•°æ®å±‚
â”œâ”€ Day 1-2:
â”‚  â”œâ”€ å®ç° BaseCrawler
â”‚  â”œâ”€ è¿ç§» CN çˆ¬è™«
â”‚  â””â”€ å®ç°æ•°æ®æ ‡å‡†åŒ–
â”‚
â”œâ”€ Day 3-4:
â”‚  â”œâ”€ å®ç°ç–¾ç—…æ˜ å°„ï¼ˆå‘é‡æœç´¢ï¼‰
â”‚  â”œâ”€ PostgreSQL schema è®¾è®¡
â”‚  â””â”€ æ•°æ®å­˜å‚¨å±‚
â”‚
â””â”€ Day 5:
   â”œâ”€ é›†æˆæµ‹è¯•
   â””â”€ æ€§èƒ½ä¼˜åŒ–
```

### Phase 2: AIå±‚é‡æ„ï¼ˆWeek 3-4ï¼‰

```bash
Week 3: éªŒè¯ç³»ç»Ÿ
â”œâ”€ Day 1-2:
â”‚  â”œâ”€ å®ç°è§„åˆ™éªŒè¯å™¨
â”‚  â”œâ”€ å®ç°ç»Ÿè®¡éªŒè¯å™¨
â”‚  â””â”€ å®ç°é›†æˆéªŒè¯å™¨
â”‚
â”œâ”€ Day 3-4:
â”‚  â”œâ”€ å®ç°æ™ºèƒ½é™çº§ç³»ç»Ÿ
â”‚  â”œâ”€ å®ç°LLMè·¯ç”±å™¨
â”‚  â””â”€ æ¨¡æ¿ç³»ç»Ÿ
â”‚
â””â”€ Day 5:
   â””â”€ éªŒè¯ç³»ç»Ÿæµ‹è¯•

Week 4: AI Agents
â”œâ”€ Day 1-3:
â”‚  â”œâ”€ å®ç° BaseAgent
â”‚  â”œâ”€ å®ç°å„ä¸“å®¶Agent
â”‚  â””â”€ Agentåä½œæœºåˆ¶
â”‚
â”œâ”€ Day 4:
â”‚  â””â”€ LangChain é›†æˆ
â”‚
â””â”€ Day 5:
   â””â”€ ç«¯åˆ°ç«¯æµ‹è¯•
```

### Phase 3: ç”Ÿæˆå’Œå‘å¸ƒï¼ˆWeek 5-6ï¼‰

```bash
Week 5: æŠ¥å‘Šç”Ÿæˆ
â”œâ”€ Day 1-2:
â”‚  â”œâ”€ æŠ¥å‘Šç”Ÿæˆå™¨é‡æ„
â”‚  â””â”€ å¯è§†åŒ–æ¨¡å—
â”‚
â”œâ”€ Day 3-4:
â”‚  â”œâ”€ ç½‘ç«™æ„å»ºå™¨
â”‚  â””â”€ Astro é›†æˆ
â”‚
â””â”€ Day 5:
   â””â”€ é‚®ä»¶æœåŠ¡é‡æ„

Week 6: éƒ¨ç½²å’Œä¼˜åŒ–
â”œâ”€ Day 1-2:
â”‚  â”œâ”€ Docker Compose é…ç½®
â”‚  â”œâ”€ CI/CD è®¾ç½®
â”‚  â””â”€ ç›‘æ§ç³»ç»Ÿ
â”‚
â”œâ”€ Day 3-4:
â”‚  â”œâ”€ æ€§èƒ½ä¼˜åŒ–
â”‚  â”œâ”€ å‹åŠ›æµ‹è¯•
â”‚  â””â”€ APIæ–‡æ¡£
â”‚
â””â”€ Day 5:
   â””â”€ ä¸Šçº¿å‡†å¤‡
```

---

## ğŸ“Š æˆæœ¬æ•ˆç›Šåˆ†æ

### å¼€å‘æŠ•å…¥

| é˜¶æ®µ | æ—¶é—´ | äººåŠ› | è¯´æ˜ |
|------|------|------|------|
| Phase 1 | 2å‘¨ | 1äºº | å¯å…ˆéƒ¨åˆ†è¿ç§» |
| Phase 2 | 2å‘¨ | 1äºº | æ ¸å¿ƒé‡æ„ |
| Phase 3 | 2å‘¨ | 1äºº | å®Œå–„åŠŸèƒ½ |
| æ€»è®¡ | 6å‘¨ | 1äºº | å¯å¹¶è¡Œæ—§ç³»ç»Ÿ |

### æ”¶ç›Šå¯¹æ¯”

| æŒ‡æ ‡ | æ—§æ¶æ„ | æ–°æ¶æ„ | æ”¹è¿› |
|------|--------|--------|------|
| APIæˆæœ¬/æœˆ | $26 | $4-6 | â†“80% |
| ç»´æŠ¤æ—¶é—´/å‘¨ | 10h | 2h | â†“80% |
| æ·»åŠ æ–°å›½å®¶ | 2å¤© | 2å°æ—¶ | â†“90% |
| æ·»åŠ æ–°ç–¾ç—… | æ‰‹åŠ¨ | è‡ªåŠ¨ | 100% |
| å¤±è´¥æ¢å¤ | æ—  | è‡ªåŠ¨ | 100% |
| ä»£ç è´¨é‡ | D | A | æ˜¾è‘—æå‡ |

---

## ä¸‹ä¸€æ­¥

å‡†å¤‡å¥½å¼€å§‹äº†å—ï¼Ÿæˆ‘å¯ä»¥ï¼š

1. **åˆ›å»ºPhase 1éª¨æ¶** - æ­å»ºæ–°é¡¹ç›®ç»“æ„
2. **å®ç°ç–¾ç—…æ³¨å†Œè¡¨** - è§£å†³è‡ªåŠ¨è¯†åˆ«é—®é¢˜
3. **å®ç°éªŒè¯ç³»ç»Ÿ** - è§£å†³ç©ºå­—ç¬¦ä¸²é—®é¢˜
4. **è®¾è®¡æ•°æ®åº“Schema** - PostgreSQLè®¾è®¡
5. **ç¼–å†™è¿ç§»è„šæœ¬** - ä»æ—§ç³»ç»Ÿè¿ç§»

**ä½ æƒ³ä»å“ªé‡Œå¼€å§‹ï¼Ÿ** ğŸš€
